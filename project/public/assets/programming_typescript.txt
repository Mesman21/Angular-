Частина I: Вступ до TypeScript та базові типи

Розділ 1: Переваги типізації

TypeScript, надбудова над JavaScript, розроблена Microsoft, має одну фундаментальну мету: зробити JavaScript масштабованим, передбачуваним і надійним. У світі, де JavaScript домінує не лише у браузерах, але й на серверах (Node.js), управління великими кодовими базами стало критичною проблемою. Саме тут TypeScript вступає у гру, надаючи розробникам інструменти для статичного аналізу коду.

Основна перевага статичної типізації, яку пропонує TypeScript, полягає в тому, що більшість помилок можна виявити на етапі компіляції (або навіть під час написання коду в IDE, наприклад, VS Code) до того, як код буде запущено. Це значно підвищує якість коду та швидкість розробки. Замість того, щоб чекати, поки користувач виявить помилку TypeError: cannot read property 'name' of undefined під час виконання, TypeScript сигналізує про це розробнику миттєво.

Розділ 2: Базові типи та виведення типів

TypeScript має широкий набір базових типів, які схожі на інші мови: number, string, boolean, null, undefined, symbol та bigint.

Однією з ключових особливостей TypeScript є виведення типів (Type Inference). Компілятор часто може самостійно визначити тип змінної, якщо ви ініціалізуєте її значенням, звільняючи вас від необхідності явно вказувати тип.

Наприклад:
let age = 30; // TypeScript виводить тип 'number'
let firstName = "Taras"; // TypeScript виводить тип 'string'

Якщо ви не ініціалізуєте змінну, TypeScript вимагатиме явного типу або присвоїть їй тип any (якого слід уникати):
let price: number; // Явне оголошення типу
price = 9.99;

Робота з масивами та об'єктами
Масиви в TypeScript також типізовані. Ви можете оголосити масив чисел як number[] або Array<number>.
let numbers: number[] = [1, 2, 3];
let names: string[] = ["Oleg", "Anna"];

Кортежі (tuples) — це спеціальний тип масиву, який дозволяє вам оголосити масив з фіксованою кількістю елементів, де кожен елемент має свій власний тип:
let coordinates: [number, number] = [40.7128, 74.0060];

Розділ 3: Типізація функцій

Типізація функцій є основою надійної архітектури. У TypeScript ви можете типізувати:
Параметри функції: Вказують, які типи даних функція очікує.
Повертане значення: Вказує, який тип даних функція повертає.

// Явне оголошення типів параметрів і повертаного значення
function calculateArea(width: number, height: number): number {
return width * height;
}

// Функція, яка нічого не повертає (void)
function logMessage(message: string): void {
console.log(message);
}

Виведення типів також працює для повертаного значення, але явне оголошення часто є найкращою практикою для API-функцій, щоб гарантувати їхню коректну роботу. Типи функцій можуть бути оголошені за допомогою псевдонімів типів (type aliases) або інтерфейсів для створення повторно використовуваних сигнатур функцій.

Розділ 4: Юніон-типи та Перетин типів

Для гнучкості TypeScript пропонує юніон-типи (Union Types) та перетини типів (Intersection Types).
Юніон-типи (|): Змінна може мати один із кількох типів. Це дуже корисно для функцій, які приймають різні вхідні дані.
type ID = number | string;

function printID(id: ID) {
console.log(Your ID is: ${id});
}

Перетини типів (&): Це комбінує кілька типів в один новий тип, який повинен мати всі властивості кожного типу. Використовується для змішування функціоналу.
type Draggable = { drag: () => void };
type Resizable = { resize: () => void };

type UIWidget = Draggable & Resizable; // Об'єкт має мати і drag(), і resize()

Розділ 5: Робота з типами "Unknown" та "Any"

Тип any вимикає всі перевірки TypeScript і по суті повертає вас до звичайного JavaScript. Його слід уникати.
Натомість, використовуйте тип unknown. Змінна типу unknown може зберігати будь-яке значення, але ви не можете викликати на ній методи чи отримати доступ до її властивостей без попередньої перевірки типу (звуження типу). Це змушує писати безпечний код.
function processValue(value: unknown) {
// Помилка: Операція не дозволена, поки ми не перевіримо тип
// console.log(value.toUpperCase());

if (typeof value === 'string') {
// Тепер TypeScript знає, що value є 'string'
console.log(value.toUpperCase());
}
}

Розділ 6: Soundness та Type Narrowing

Soundness — це властивість системи типів, яка гарантує, що правильно типізований код ніколи не призведе до помилок під час виконання. JavaScript, і, отже, TypeScript, не є повністю "sound" (через гнучкість JS), але TypeScript робить усе можливе, щоб запобігти помилкам за допомогою звуження типів (Type Narrowing).
Звуження типів — це процес, за допомогою якого TypeScript уточнює тип змінної в певних областях коду. Це досягається за допомогою:
Перевірки typeof: (наприклад, typeof x === 'string')
Перевірки instanceof: (для класів)
Операторів in: (для перевірки наявності властивості в об'єкті)
Дискримінованих юніонів (Discriminated Unions): (використовуючи спільне поле, наприклад type або kind).
Використання цих механізмів дозволяє нам писати функції, які безпечно обробляють різні типи даних без використання any. Це є ключовим для побудови великих, надійних додатків. Це закінчує наше поглиблене занурення в основи типізації TypeScript. У наступних частинах ми розглянемо більш складні теми, такі як дженерики, класи та просунуті можливості компілятора.